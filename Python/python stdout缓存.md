---
layout: post
title: python输出信息被缓存
category: Python
tags: stdout
---
### 转自： https://github.com/jessiejia/jessiejia.github.io/blob/master/_posts/2014-08-15-python%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF%E8%A2%AB%E7%BC%93%E5%AD%98.md
### python的print指令有缓存

调试python的时候，print信息到后台终端，发现不能及时输出来。

原因：

**print实际上调用``sys.stdout.write("message")``**，而stdout本身使用``行缓存``。


几种解决方案：

* ``sys.stdout.flush()``  //添加在代码中，用来刷新缓存，但是感觉像狗皮膏药

* ``python -u xxxx.py``  //参数-u，禁用stdout缓存

* 程序的第一行指定 ``#!/usr/bin/python -u`` 然后程序加可执行权限来运行

* ``PYTHONUNBUFFERED=1 python xxxx.py``   //指定环境变量PYTHONUNBUFFERED

* 把 ``export PYTHONUNBUFFERED=1`` 写到 .bashrc 里去。

* ``sys.stdout = os.fdopen(sys.stdout.fileno(), ‘w’, 0)`` //最简单实用，部署起来更方便



### 关于标准输入输出 stdin, stdout, stderr

**Linux的本质就是一切皆文件，输入输出设备也是以文件形式存在和管理的。**

内核启动的时候默认打开这三个I/O设备文件：标准输入文件stdin，标准输出文件stdout，标准错误输出文件stderr，分别得到文件描述符 0, 1, 2。 



* ``stderr`` 
	* 不缓存，为了及时输出错误信息，``sys.stderr.write("error")``没有缓存

* ``stdout`` 
	
	* 行间缓存，遇到回车(\n)才会输出，为了减少磁盘io，``sys.stdout.write("message")``使用`行缓存`


### 那么为什么要用缓冲区？
<http://see.xidian.edu.cn/cpp/html/2413.html>

缓冲区又称为缓存，它是内存空间的一部分。

缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。

#### 为什么要引入缓冲区

比如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。

又比如，我们使用打印机打印文档，由于打印机的打印速度相对较慢，我们先把文档输出到打印机相应的缓冲区，打印机再自行逐步打印，这时我们的CPU可以处理别的事情。

缓冲区就是一块内存区，它用在输入输出设备和CPU之间，用来缓存数据。它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作。

#### 缓冲区的类型

缓冲区 分为三种类型：全缓冲、行缓冲和不带缓冲。

1. **全缓冲**

	* 在这种情况下，当填满标准I/O缓存后才进行实际I/O操作。全缓冲的典型代表是对磁盘文件的读写。

2. **行缓冲**

	* 在这种情况下，当在输入和输出中遇到换行符时，执行真正的I/O操作。这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I/O操作。典型代表是标准输入(stdin)和标准输出(stdout)。

3. **不带缓冲**

	* 也就是不进行缓冲，标准出错(stderr)是典型代表，这使得出错信息可以直接尽快地显示出来。


#### 缓冲区的大小

如果我们没有自己设置缓冲区的话，系统会默认为标准输入输出设置一个缓冲区，这个缓冲区的大小通常是512个字节的大小。

缓冲区大小由 stdio.h 头文件中的宏 BUFSIZ 定义，如果希望查看它的大小，包含头文件，直接输出它的值即可：
	
	printf("%d", BUFSIZ);

缓冲区的大小是可以改变的，也可以将文件关联到自定义的缓冲区，详情可以查看 setvbuf() 和 setbuf() 函数。

#### 缓冲区的刷新（清空）

下列情况会引发缓冲区的刷新：

* 缓冲区满时；
* 行缓冲区遇到回车时；
* 关闭文件；
* 使用特定函数刷新缓冲区。
python输出信息被缓存.md
